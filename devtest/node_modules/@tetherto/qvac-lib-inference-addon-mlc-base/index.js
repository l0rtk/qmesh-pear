'use strict'

const path = require('bare-path')
const fs = require('bare-fs')

const BaseInference = require('@tetherto/qvac-lib-inference-base')

const { QvacErrorBase } = require('@tetherto/qvac-lib-error-base')
const { QvacInferenceAddonMlcBaseError, ERR_CODES } = require('./lib/error')

class MLCInference extends BaseInference {
  /**
   * Load weights either from filepath or from a Loader stream.
   * @param {string|object} source - File path string or Loader object
   * @param {boolean} [close=true] - Whether to close the loader stream
   * @param {object} [progressReporter = null] - Progress report instance
   */
  async _loadWeights (source, close = true, progressReporter = null) {
    if (!source) {
      throw new QvacInferenceAddonMlcBaseError(
        ERR_CODES.LOADING_WEIGHTS_FAILED,
        'Source is required'
      )
    }

    const { loader, filename } = await this._setupLoader(source)
    this.logger.info('Loading weights from stream', { filename, close })

    try {
      for await (const chunk of loader) {
        await this.addon.loadWeights({ filename, contents: chunk, completed: false })
        this.logger.debug('Sent chunk to addon.loadWeights', { filename, chunkSize: chunk.length })

        if (progressReporter) {
          progressReporter.update(filename, chunk.length)
          this.logger.debug('Progress report updated', { filename, bytes: chunk.length })
        }
      }

      await this.addon.loadWeights({ filename, completed: true })
      this.state.weightsLoaded = true

      this.logger.debug('Completed streaming all chunks', { filename })

      if (progressReporter) {
        progressReporter.completeFile(filename)
        this.logger.debug('Progress report marked complete', { filename })
      }

      if (close && loader.close) {
        loader.close()
        this.logger.debug('Loader stream closed')
      }
    } catch (err) {
      this._handleError(err, ERR_CODES.LOADING_WEIGHTS_FAILED)
    }
  }

  /**
   * Download weights to disk.
   * @param {string|object} source - File path string or Loader object
   * @param {string} [diskPath=''] - Directory path for saving to disk
   * @param {object} [progressReporter = null] - Progress reporting instance
   */
  async _downloadWeights (source, diskPath = '', progressReporter = null) {
    if (!source) {
      throw new QvacInferenceAddonMlcBaseError(
        ERR_CODES.DOWNLOADING_WEIGHTS_FAILED,
        'Source is required'
      )
    }

    const { loader, filename, filepath } = await this._setupLoader(source)
    this.logger.info('Downloading weights to disk', { filename, diskPath })

    let fileStream = null

    try {
      const fileDest = path.join(diskPath, filepath)
      fs.mkdirSync(path.dirname(fileDest), { recursive: true })
      fileStream = fs.createWriteStream(fileDest)

      await new Promise((resolve, reject) => {
        loader.pipe(fileStream)
        loader.on('data', (chunk) => {
          this.logger.debug('Wrote chunk to disk', { filename, chunkSize: chunk.length })
          if (progressReporter) {
            progressReporter.update(filename, chunk.length)
            this.logger.debug('Progress report updated', { filename, bytes: chunk.length })
          }
        })
        fileStream.on('finish', resolve)
        fileStream.on('error', reject)
        loader.on('error', reject)
      })

      this.logger.debug('Completed downloading all chunks', { filename })

      if (progressReporter) {
        progressReporter.completeFile(filename)
        this.logger.debug('Progress report marked complete', { filename })
      }
    } catch (err) {
      if (fileStream) {
        fileStream.destroy()
      }
      this._handleError(err, ERR_CODES.DOWNLOADING_WEIGHTS_FAILED)
    }
  }

  /**
   * Unloads weights from the memory.
   * @returns {Promise<void>} - A promise that resolves when the weights are unloaded.
   */
  async _unloadWeights () {
    try {
      this.logger.info('Unloading weights')
      await this.addon.unloadWeights()
      this.logger.debug('Weights unloaded successfully')

      this.state.weightsLoaded = false
    } catch (err) {
      this._handleError(err, ERR_CODES.UNLOADING_WEIGHTS_FAILED)
    }
  }

  /**
   * Setup loader and extract metadata from source.
   * @private
   */
  async _setupLoader (source) {
    let loader
    let filename
    let filepath = null

    if (typeof source === 'string') {
      filepath = source
      filename = path.basename(filepath)

      this.logger.debug('Getting stream for weights file', { filepath })
      loader = await this.loader.getStream(filepath)
    } else {
      loader = source
      filename = loader.filename || 'weights'
    }

    return { loader, filename, filepath }
  }

  /**
   * Handle errors consistently across methods.
   * @private
   */
  _handleError (err, errorCode) {
    // Re-throw if it's already a QvacErrorBase
    if (Object.getPrototypeOf(err)?.constructor?.name === QvacErrorBase.name) {
      throw err
    }

    throw new QvacInferenceAddonMlcBaseError(errorCode, err.message)
  }
}

module.exports = MLCInference
