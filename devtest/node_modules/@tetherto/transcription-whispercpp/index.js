'use strict'

const path = require('bare-path')
const BaseInference = require('@tetherto/infer-base/WeightsProvider/BaseInference')
const WeightsProvider = require('@tetherto/infer-base/WeightsProvider/WeightsProvider')

const { WhisperInterface } = require('./whisper')

const END_OF_INPUT = 'end of job'

/**
 * GGML client implementation for the Whisper transcription model
 */
class TranscriptionWhispercpp extends BaseInference {
  /**
   * Creates an instance of WhisperClient.
   * @constructor
   * @param {Object} args - arguments for inference setup
   * @param {Object} config - environment-specific inference setup configuration
   */
  constructor (
    { loader, logger = null, modelName, vadModelName, diskPath, ...args },
    config
  ) {
    super({ logger, loader })

    this._diskPath = diskPath || ''
    this._modelName = modelName
    this._vadModelName = vadModelName
    this._config = config
    this.weightsProvider = new WeightsProvider(loader, this.logger)

    this.params = config.whisperConfig

    this.logger.debug('TranscriptionWhispercpp constructor called', {
      params: this.params,
      config: this._config,
      diskPath: this._diskPath
    })
  }

  /**
   * Load model, weights, and activate addon.
   * @param {boolean} [closeLoader=false] - Close loader when done.
   * @param {Function} [reportProgressCallback] - Hook for progress updates.
   */
  async _load (closeLoader = false, reportProgressCallback) {
    this.logger.debug('Loader ready')

    await this.downloadWeights(reportProgressCallback, { closeLoader })

    const configurationParams = {
      path: this._config.path || this._getModelFilePath(),
      opts: { stats: Boolean(this._config.enableStats) },
      whisperConfig: {
        mode: this.params.mode || 'batch',
        output_format: this.params.output_format || 'plaintext',
        min_seconds: this.params.min_seconds || 2,
        max_seconds: this.params.max_seconds || 6,
        vad_model: this._config.vadModelPath || this._getVadModelFilePath(),
        vad_threshold: this.params.vad_threshold || 0.6,
        vad_min_speech_duration_ms:
          this.params.vad_min_speech_duration_ms || 500,
        vad_min_silence_duration_ms:
          this.params.vad_min_silence_duration_ms || 300,
        vad_max_speech_duration_s:
          this.params.vad_max_speech_duration_s || 15.0,
        vad_speech_pad_ms: this.params.vad_speech_pad_ms || 100,
        vad_samples_overlap: this.params.vad_samples_overlap || 0.2,
        audio_format: this.params.audio_format || 's16le'
      }
    }

    this.addon = this._createAddon(configurationParams)

    // For whisper.cpp, the model file contains everything - no separate weight loading needed
    await this.addon.activate()
    this.logger.debug('Addon activated')
  }

  _getModelFilePath () {
    return path.join(this._diskPath, this._modelName)
  }

  _getVadModelFilePath () {
    return this._vadModelName
      ? path.join(this._diskPath, this._vadModelName)
      : ''
  }

  async _runInternal (audioStream) {
    const jobId = await this.addon.append({
      type: 'audio',
      input: new Uint8Array()
    })

    const response = this._createResponse(jobId)

    this._handleAudioStream(audioStream).catch(response.failed.bind(response))
    return response
  }

  async _handleAudioStream (audioStream) {
    this.logger.debug('Start handling audio stream', { file: this.file })
    for await (const chunk of audioStream) {
      this.logger.debug('Appending audio chunk', { chunkLength: chunk.length })
      await this.addon.append({
        type: 'audio',
        input: new Uint8Array(chunk.buffer)
      })
    }
    this.logger.debug('Sending end-of-input signal')
    await this.addon.append({ type: END_OF_INPUT })
  }

  async _downloadWeights (reportProgressCallback, opts) {
    const models = this._vadModelName
      ? [this._modelName, this._vadModelName]
      : [this._modelName]

    this.logger.info('Loading weight files:', models)

    const result = await this.weightsProvider.downloadFiles(
      models,
      this._diskPath,
      {
        closeLoader: opts.closeLoader,
        onDownloadProgress: reportProgressCallback
      }
    )
    this.logger.info('Weight files downloaded successfully', { models })
    return result
  }

  /**
   * Instantiate the native addon with the given parameters.
   * @param {Object} configurationParams - Configuration parameters for the addon
   * @param {string} configurationParams.path - Local file or directory path
   * @param {Object} configurationParams.settings - LLM-specific settings
   * @returns {Addon} The instantiated addon interface
   */
  _createAddon (configurationParams) {
    this.logger.info(
      'Creating Whisper interface with configuration:',
      configurationParams
    )
    const binding = require('./binding')
    return new WhisperInterface(
      binding,
      configurationParams,
      this._outputCallback.bind(this),
      this.logger.info.bind(this.logger)
    )
  }
}

module.exports = TranscriptionWhispercpp
