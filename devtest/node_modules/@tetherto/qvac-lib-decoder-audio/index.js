'use strict'

const QvacResponse = require('@tetherto/qvac-lib-response')
const GGMLBase = require('@tetherto/infer-ggml-base')
const { GSTDecoderInterface } = require('./gstreamer')
const createStreamAccumulator = require('./utils/createStreamAccumulator')

const END_OF_INPUT = 'end of job'

/**
 * GSTDecoder client implementation for the Whisper transcription model
 */
class GSTDecoder extends GGMLBase {
  /**
   * Creates an instance of GSTDecoder.
   * @constructor
   * @param {Object} config - environment-specific inference setup configuration
   */

  constructor ({ config, ...args }) {
    super(args)
    this.config = config
  }

  async load () {
    const config = {
      audioFormat: this.config.audioFormat || 'encoded',
      sampleRate: this.config.sampleRate || 16000
    }

    this.logger.info('Loading GSTDecoder with config:', config)
    this.addon = this.createAddon(config)

    await this.addon.activate()
    this.logger.info('GSTDecoder activated successfully')
  }

  async _runInternal (audioStream) {
    this.logger.info('Starting new audio stream processing')
    const response = new QvacResponse({
      cancelHandler: () => this.addon.cancel(jobId),
      pauseHandler: () => this.addon.pause(),
      continueHandler: () => this.addon.continue()
    })

    const jobId = await this.addon.append({
      type: 'audio',
      input: new Uint8Array().buffer,
      priority: 1
    })

    this.logger.info('Created new job with ID:', jobId)
    this._saveJobToResponseMapping(jobId, response)

    this._handleAudioStream(audioStream).catch(err => {
      this.logger.error('Error processing audio stream:', err)
      response.failed(err)
    })
    return response
  }

  async _handleAudioStream (audioStream) {
    this.logger.info('Starting audio stream handling')
    const streamAccumulator = createStreamAccumulator({
      onChunk: async chunk => {
        this.logger.debug('Processing audio chunk of size:', chunk.byteLength)
        await this.addon.append({
          type: 'audio',
          input: chunk.buffer,
          priority: 1
        })
      },
      onFinish: async () => {
        this.logger.info('Audio stream finished, sending end of input')
        await this.addon.append({ type: END_OF_INPUT })
      }
    })

    for await (const chunk of audioStream) {
      await streamAccumulator.processData(chunk)
    }

    await streamAccumulator.finish()
    this.logger.info('Audio stream handling completed')
  }

  async getStatus () {
    const status = await this.addon.status()
    this.logger.debug('Current status:', status)
    return status
  }

  createAddon (config) {
    this.logger.info('Creating new GSTDecoderInterface instance')
    return new GSTDecoderInterface(
      config,
      this._outputCallback.bind(this),
      this.logger.info.bind(this.logger)
    )
  }
}

module.exports = GSTDecoder
