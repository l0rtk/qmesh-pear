'use strict'

/**
 * Reserved internal error codes
 * @private
 */
const ERR_CODES = Object.freeze({
  // Internal error codes (0-999)
  UNKNOWN_ERROR_CODE: 0,
  INVALID_CODE_DEFINITION: 1,
  ERROR_CODE_ALREADY_EXISTS: 2,
  MISSING_ERROR_DEFINITION: 3
})

/**
 * Map of error codes to their content (name and message)
 * @private
 */
const codeToContent = {
  [ERR_CODES.UNKNOWN_ERROR_CODE]: {
    name: 'UNKNOWN_ERROR_CODE',
    message: code => `Unknown QVAC error code: ${code}`
  },
  [ERR_CODES.INVALID_CODE_DEFINITION]: {
    name: 'INVALID_CODE_DEFINITION',
    message: code => `Invalid definition for error code: ${code}`
  },
  [ERR_CODES.ERROR_CODE_ALREADY_EXISTS]: {
    name: 'ERROR_CODE_ALREADY_EXISTS',
    message: code => `Error code already exists: ${code}`
  },
  [ERR_CODES.MISSING_ERROR_DEFINITION]: {
    name: 'MISSING_ERROR_DEFINITION',
    message: code => `Missing name or message for error code: ${code}`
  }
}

/**
 * Base class for all QVAC errors
 * Extends the standard Error class with QVAC-specific functionality
 */
class QvacErrorBase extends Error {
  /**
   * Creates a new QVAC error
   * @param {number} code - The error code
   * @param {Array|string} [adds] - Additional arguments to format the message
   * @param {Error} [cause] - The original error that caused this one
   */
  constructor (code, adds, cause) {
    let msgContent = ''
    const codeObj = codeToContent[code]

    // Format message based on the adds parameter
    const unknownError = codeToContent[ERR_CODES.UNKNOWN_ERROR_CODE]
    if (!codeObj) {
      msgContent = unknownError.message(code)
    } else if (typeof codeObj.message === 'function') {
      msgContent = codeObj.message(...(Array.isArray(adds) ? adds : [adds]))
    } else if (typeof codeObj.message === 'string') {
      msgContent = codeObj.message + (adds ? ` ${adds}` : '')
    }

    super(msgContent, { cause })

    if (!codeObj) {
      // Handle unknown error code
      this.code = ERR_CODES.UNKNOWN_ERROR_CODE
      this.name = unknownError.name
      return
    }

    this.code = code
    this.name = codeObj.name

    // Capture stack trace, excluding the constructor call from the stack
    Error.captureStackTrace(this, this.constructor)
  }

  /**
   * Serializes the error to a plain object
   * @returns {Object} Serialized error
   */
  toJSON () {
    return {
      name: this.name,
      code: this.code,
      message: this.message,
      stack: this.stack
    }
  }
}

/**
 * Registers new error codes with their names and messages
 * @param {Object} codes - Map of error codes to their definitions
 * @throws {QvacErrorBase} If a code is already registered or has invalid definition
 */
function addCodes (codes) {
  for (const [code, def] of Object.entries(codes)) {
    const numericCode = Number(code)

    if (codeToContent[numericCode]) {
      throw new QvacErrorBase(ERR_CODES.ERROR_CODE_ALREADY_EXISTS, numericCode)
    }

    if (!def || typeof def !== 'object') {
      throw new QvacErrorBase(ERR_CODES.INVALID_CODE_DEFINITION, numericCode)
    }

    if (!def.name || !def.message) {
      throw new QvacErrorBase(ERR_CODES.MISSING_ERROR_DEFINITION, numericCode)
    }

    codeToContent[numericCode] = {
      name: def.name,
      message: def.message
    }
  }
}

/**
 * Gets all registered error codes and their definitions
 * @returns {Object} Map of all registered error codes
 */
function getRegisteredCodes () {
  return JSON.parse(JSON.stringify(codeToContent))
}

/**
 * Checks if a code is already registered
 * @param {number} code - The error code to check
 * @returns {boolean} True if the code is already registered
 */
function isCodeRegistered (code) {
  return !!codeToContent[code]
}

module.exports = {
  QvacErrorBase,
  addCodes,
  getRegisteredCodes,
  isCodeRegistered,
  INTERNAL_ERROR_CODES: ERR_CODES
}

module.exports.default = QvacErrorBase
